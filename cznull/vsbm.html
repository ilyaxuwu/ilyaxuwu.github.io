<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>Adaptif Kaliteli Shader</title>
    <style>
        body { margin: 0; overflow: hidden; background: #131115; }
        canvas { display: block; }
        #info-display {
            position: fixed;
            left: 10px;
            top: 10px;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 5px 10px;
            font-family: monospace;
            border-radius: 4px;
            z-index: 100;
        }
        #config-container { position: fixed; left: 10px; top: 60px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; display: none; z-index: 20;}
        #btn-config { position: fixed; left: 10px; top: 110px; z-index: 10; }
    </style>
</head>
<body>
    <canvas id="c1"></canvas>
    <button id="btn-config">CONFIG</button>
    <div id="config-container">
        <textarea name="" id="kernel" cols="40" rows="15"></textarea><br />
        <button id="apply">APPLY</button>
        <button id="cancel">CANCEL</button>
    </div>

<script>
    alert("created by cznull@bilibili, Made fake one by ilyax aka liyaa");
    let canvas, gl, shaderProgram;
    let glPosition, glRight, glForward, glUp, glOrigin, glResolution, glLen;
    let ang1 = 2.8, ang2 = 0.4, len = 1.6, cenx = 0.0, ceny = 0.0, cenz = 0.0;
    let mouseX = 0, mouseY = 0, isMouseDownLeft = false, isMouseDownRight = false, hasMouseMoved = false;
    const infoDisplay = document.getElementById('info-display');
    let frameTimes = [];
    let currentFps = 0;

    const TARGET_FPS_LOW = 25;
    const TARGET_FPS_HIGH = 55;

    const qualityLevels = [
        { name: 'Ultra', steps: 200, size: 0.01, solver: 5 },
        { name: 'Yüksek', steps: 120, size: 0.012, solver: 4 },
        { name: 'Orta', steps: 80, size: 0.015, solver: 4 },
        { name: 'Düşük', steps: 50, size: 0.02, solver: 3 },
        { name: 'Patates', steps: 30, size: 0.025, solver: 2 }
    ];
    let currentQualityIndex = 1;
    let KERNEL = `
float kernal(vec3 ver){
    vec3 a = ver;
    float b,c,d,e;
    for(int i=0; i<5; i++){
        b = length(a);
        c = atan(a.y, a.x) * 8.0;
        e = 1.0/b;
        d = acos(a.z/b) * 8.0;
        b = pow(b, 8.0);
        a = vec3(b*sin(d)*cos(c), b*sin(d)*sin(c), b*cos(d)) + ver;
        if(b > 6.0){ break; }
    }
    return 4.0 - dot(a, a);
}`;

    const VSHADER_SOURCE = `
#version 100
precision highp float;
attribute vec2 position;
varying vec3 dir;
uniform vec3 right, forward, up, origin;
uniform vec2 resolution;
void main() {
    float aspect = resolution.y / resolution.x;
    vec2 screenPos = position;
    screenPos.y *= aspect;
    dir = forward + right * screenPos.x + up * screenPos.y;
    gl_Position = vec4(position, 0.0, 1.0);
}`;
        function generateFragmentShaderSource(level) {
        return `
#version 100
#define PI 3.14159265358979324
precision highp float;
varying vec3 dir;
uniform vec3 origin;
uniform float len;
float kernal(vec3 ver);

const int MAX_STEPS = ${level.steps};
const float STEP_SIZE = ${level.size};
const int SOLVER_STEPS = ${level.solver};

void main() {
    vec3 color = vec3(0.0);
    vec3 rayDir = normalize(dir);
    float v_prev = kernal(origin);
    for (int k = 1; k < MAX_STEPS; k++) {
        float dist = STEP_SIZE * len * float(k);
        vec3 p = origin + rayDir * dist;
        float v_curr = kernal(p);
        if (v_curr * v_prev < 0.0) {
            vec3 p1 = origin + rayDir * (dist - STEP_SIZE * len);
            vec3 p2 = p;
            for(int i = 0; i < SOLVER_STEPS; i++) {
                vec3 p_mid = (p1 + p2) * 0.5;
                if(kernal(p_mid) * v_prev > 0.0) { p1 = p_mid; } else { p2 = p_mid; }
            }
            vec3 final_pos = (p1 + p2) * 0.5;
            vec2 e = vec2(dist * 0.00025, 0.0);
            vec3 n = normalize(vec3(
                kernal(final_pos + e.xyy) - kernal(final_pos - e.xyy),
                kernal(final_pos + e.yxy) - kernal(final_pos - e.yxy),
                kernal(final_pos + e.yyx) - kernal(final_pos - e.yyx)
            ));
            float r1_squared = dot(final_pos, final_pos);
            vec3 baseColor = vec3(
                sin(r1_squared * 10.0) * 0.5 + 0.5,
                sin(r1_squared * 10.0 + 2.05) * 0.5 + 0.5,
                sin(r1_squared * 10.0 - 2.05) * 0.5 + 0.5
            );
            vec3 reflect = reflect(rayDir, n);
            float r3 = reflect.x*0.276+reflect.y*0.920+reflect.z*0.276;
            float r4 = n.x*0.276+n.y*0.920+n.z*0.276;
            r3 = max(0.0, r3);
            r3 = r3*r3*r3*r3;
            r3 = r3 * 0.45 + r4 * 0.25 + 0.3;
            color = baseColor * r3;
            break; 
        }
        v_prev = v_curr;
        if (dist > len * 2.0) break;
    }
    gl_FragColor = vec4(color, 1.0);
}`;
    }

    function setup() {
        canvas = document.getElementById('c1');
        gl = canvas.getContext('webgl', { antialias: false }) || canvas.getContext('experimental-webgl');
        if (!gl) { alert('WebGL desteklenmiyor!'); return; }

        recompileShaders();
        
        setupUI();
        addEventListeners();
        window.onresize = onResize;
        onResize();
        
        setInterval(adjustQuality, 1000);
        requestAnimationFrame(draw);
    }

    function draw(now) {
        // FPS Hesaplama
        const msPassed = now - (frameTimes[frameTimes.length - 1] || now);
        while (frameTimes.length > 0 && frameTimes[0] <= now - 1000) {
            frameTimes.shift();
        }
        frameTimes.push(now);
        currentFps = frameTimes.length;
        infoDisplay.innerHTML = `FPS: ${currentFps}<br>Kalite: ${qualityLevels[currentQualityIndex].name}`;

        gl.useProgram(shaderProgram);
        const camOrigin = [len * Math.cos(ang1) * Math.cos(ang2) + cenx, len * Math.sin(ang2) + ceny, len * Math.sin(ang1) * Math.cos(ang2) + cenz];
        const camRight = [Math.sin(ang1), 0, -Math.cos(ang1)];
        const camUp = [-Math.sin(ang2) * Math.cos(ang1), Math.cos(ang2), -Math.sin(ang2) * Math.sin(ang1)];
        const camForward = [-Math.cos(ang1) * Math.cos(ang2), -Math.sin(ang2), -Math.sin(ang1) * Math.cos(ang2)];

        gl.uniform2f(glResolution, canvas.width, canvas.height);
        gl.uniform1f(glLen, len);
        gl.uniform3fv(glOrigin, camOrigin);
        gl.uniform3fv(glRight, camRight);
        gl.uniform3fv(glUp, camUp);
        gl.uniform3fv(glForward, camForward);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(draw);
    }
    
    function adjustQuality() {
        const lastQualityIndex = currentQualityIndex;

        if (currentFps < TARGET_FPS_LOW && currentQualityIndex < qualityLevels.length - 1) {
            currentQualityIndex++;
        } 
        else if (currentFps > TARGET_FPS_HIGH && currentQualityIndex > 0) {
            currentQualityIndex--;
        }

        if (lastQualityIndex !== currentQualityIndex) {
            console.log(`Kalite değişti: ${qualityLevels[lastQualityIndex].name} -> ${qualityLevels[currentQualityIndex].name}`);
            recompileShaders();
        }
    }

    function recompileShaders() {
        const quality = qualityLevels[currentQualityIndex];
        const fragSource = generateFragmentShaderSource(quality);

        const vertShader = createShader(gl, gl.VERTEX_SHADER, VSHADER_SOURCE);
        const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragSource + KERNEL);
        const newProgram = createProgram(gl, vertShader, fragShader);

        if (newProgram) {
            shaderProgram = newProgram;
            glPosition = gl.getAttribLocation(shaderProgram, 'position');
            glRight = gl.getUniformLocation(shaderProgram, 'right');
            glForward = gl.getUniformLocation(shaderProgram, 'forward');
            glUp = gl.getUniformLocation(shaderProgram, 'up');
            glOrigin = gl.getUniformLocation(shaderProgram, 'origin');
            glResolution = gl.getUniformLocation(shaderProgram, 'resolution');
            glLen = gl.getUniformLocation(shaderProgram, 'len');
            
            const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            gl.vertexAttribPointer(glPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(glPosition);
        } else {
            console.error("Shader yeniden derlenemedi!");
        }
    }

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader derlenemedi:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader); return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linklenemedi:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program); return null;
        }
        return program;
    }

    function onResize() {
        const size = Math.min(window.innerWidth, window.innerHeight);
        canvas.width = size;
        canvas.height = size;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }
    
    function setupUI() {}
    function addEventListeners() {}
    setupUI = function() {
        document.getElementById("kernel").value = KERNEL;
        document.getElementById("btn-config").addEventListener("click", function() {
            const configDiv = document.getElementById("config-container");
            const isVisible = configDiv.style.display === "block";
            configDiv.style.display = isVisible ? "none" : "block";
        });
        document.getElementById("apply").addEventListener("click", function() {
            KERNEL = document.getElementById("kernel").value;
            recompileShaders();
        });
        document.getElementById("cancel").addEventListener("click", function() {
            document.getElementById("kernel").value = KERNEL;
        });
    }
    
    addEventListeners = function() {
        canvas.addEventListener("mousedown", (e) => {
            if (e.button === 0) isMouseDownLeft = true;
            if (e.button === 2) isMouseDownRight = true;
            mouseX = e.clientX; mouseY = e.clientY; hasMouseMoved = false;
        });
        document.addEventListener("mouseup", (e) => {
            if (e.button === 0) isMouseDownLeft = false;
            if (e.button === 2) isMouseDownRight = false;
        });
        document.addEventListener("mousemove", (e) => {
            if (!isMouseDownLeft && !isMouseDownRight) return;
            hasMouseMoved = true;
            const dx = e.clientX - mouseX; const dy = e.clientY - mouseY;
            if (isMouseDownLeft) {
                ang1 += dx * 0.005; ang2 += dy * 0.005;
                ang2 = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, ang2));
            }
            if (isMouseDownRight) {
                const moveSpeed = len / canvas.height;
                cenx -= (dx * Math.sin(ang1) + dy * Math.cos(ang1) * Math.sin(ang2)) * moveSpeed;
                ceny += dy * Math.cos(ang2) * moveSpeed;
                cenz += (dx * Math.cos(ang1) - dy * Math.sin(ang1) * Math.sin(ang2)) * moveSpeed;
            }
            mouseX = e.clientX; mouseY = e.clientY;
        });
        canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            len *= Math.exp(-e.deltaY * 0.001); len = Math.max(0.01, len);
        });
        canvas.addEventListener('contextmenu', e => { if(hasMouseMoved) e.preventDefault(); });
    }

    window.onload = setup;
</script>
</body>
</html>
