<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="user-scalable=no">
    <title>Optimize Edilmiş Volume Shader (Final Versiyon)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #131115; }
        canvas { display: block; }
        #config-container { position: fixed; left: 10px; top: 40px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; display: none; z-index: 20;}
        #btn-config { position: fixed; left: 10px; top: 10px; z-index: 10; }
    </style>
</head>
<body>
    <canvas id="c1"></canvas>
    <button id="btn-config">CONFIG</button>
    <div id="config-container">
        <textarea name="" id="kernel" cols="40" rows="15"></textarea><br />
        <button id="apply">APPLY</button>
        <button id="cancel">CANCEL</button>
    </div>

<script>
    alert("trigonometric and inverse trigonometric functions test. created by cznull@bilibili. Optimized by Liyaa Aka İlyax");

    let canvas, gl;
    let glPosition, glRight, glForward, glUp, glOrigin, glResolution, glLen;
    let shaderProgram;

    let ang1 = 2.8, ang2 = 0.4, len = 1.6;
    let cenx = 0.0, ceny = 0.0, cenz = 0.0;
    
    let mouseX = 0, mouseY = 0;
    let isMouseDownLeft = false, isMouseDownRight = false;
    let hasMouseMoved = false;

    // Kernel kodunu global bir değişken olarak tutalım
    let KERNEL = `
float kernal(vec3 ver){
    vec3 a = ver;
    float b,c,d,e;
    for(int i=0; i<5; i++){
        b = length(a);
        c = atan(a.y, a.x) * 8.0;
        e = 1.0/b;
        d = acos(a.z/b) * 8.0;
        b = pow(b, 8.0);
        a = vec3(b*sin(d)*cos(c), b*sin(d)*sin(c), b*cos(d)) + ver;
        if(b > 6.0){
            break;
        }
    }
    return 4.0 - dot(a, a);
}`;

    const VSHADER_SOURCE = `
#version 100
precision highp float;
attribute vec2 position;
varying vec3 dir;
uniform vec3 right, forward, up, origin;
uniform vec2 resolution;

void main() {
    float aspect = resolution.y / resolution.x;
    vec2 screenPos = position;
    screenPos.y *= aspect;
    dir = forward + right * screenPos.x + up * screenPos.y;
    gl_Position = vec4(position, 0.0, 1.0);
}`;

    const FSHADER_SOURCE = `
#version 100
#define PI 3.14159265358979324
precision highp float;

varying vec3 dir;
uniform vec3 origin;
uniform float len;

// Kernel fonksiyonu bildirimi
float kernal(vec3 ver);

// Performans ayarları
const int MAX_STEPS = 200;
const float STEP_SIZE = 0.01;
const int SOLVER_STEPS = 5;

void main() {
    vec3 color = vec3(0.0);
    vec3 rayDir = normalize(dir);
    
    float v_prev = kernal(origin);
    
    for (int k = 1; k < MAX_STEPS; k++) {
        float dist = STEP_SIZE * len * float(k);
        vec3 p = origin + rayDir * dist;
        float v_curr = kernal(p);

        if (v_curr * v_prev < 0.0) {
            vec3 p1 = origin + rayDir * (dist - STEP_SIZE * len);
            vec3 p2 = p;

            for(int i = 0; i < SOLVER_STEPS; i++) {
                vec3 p_mid = (p1 + p2) * 0.5;
                if(kernal(p_mid) * v_prev > 0.0) {
                    p1 = p_mid;
                } else {
                    p2 = p_mid;
                }
            }
            
            vec3 final_pos = (p1 + p2) * 0.5;
            
            // --- Orijinal Işıklandırma ve Renk Mantığını Buraya Geri Ekliyoruz ---

            // 1. Yüzey normalini hesapla
            vec2 e = vec2(dist * 0.00025, 0.0);
            vec3 n = normalize(vec3(
                kernal(final_pos + e.xyy) - kernal(final_pos - e.xyy),
                kernal(final_pos + e.yxy) - kernal(final_pos - e.yxy),
                kernal(final_pos + e.yyx) - kernal(final_pos - e.yyx)
            ));

            // 2. Temel rengi, orijinaldeki gibi uzaklığın karesine göre hesapla
            float r1_squared = dot(final_pos, final_pos);
            vec3 baseColor = vec3(
                sin(r1_squared * 10.0) * 0.5 + 0.5,
                sin(r1_squared * 10.0 + 2.05) * 0.5 + 0.5,
                sin(r1_squared * 10.0 - 2.05) * 0.5 + 0.5
            );

            // 3. Orijinal koddaki gibi yansıma ve ışıklandırma modelini yeniden oluşturalım
            vec3 ver = -rayDir; // Kameraya doğru olan yön (viewDir)
            vec3 reflect = reflect(rayDir, n);
            
            // Orijinal koddaki sabit vektörler ve hesaplamalar
            float r3 = reflect.x*0.276+reflect.y*0.920+reflect.z*0.276;
            float r4 = n.x*0.276+n.y*0.920+n.z*0.276;

            r3 = max(0.0, r3);
            r3 = r3*r3*r3*r3; // pow(r3, 4.0)
            r3 = r3 * 0.45 + r4 * 0.25 + 0.3;
            
            // Son rengi hesapla
            color = baseColor * r3;
            
            break; 
        }
        
        v_prev = v_curr;
        if (dist > len * 2.0) break;
    }

    gl_FragColor = vec4(color, 1.0);
}`;

    function setup() {
        canvas = document.getElementById('c1');
        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) {
            alert('WebGL desteklenmiyor!');
            return;
        }

        const vertShader = createShader(gl, gl.VERTEX_SHADER, VSHADER_SOURCE);
        const fragShader = createShader(gl, gl.FRAGMENT_SHADER, FSHADER_SOURCE + KERNEL);
        shaderProgram = createProgram(gl, vertShader, fragShader);

        glPosition = gl.getAttribLocation(shaderProgram, 'position');
        glRight = gl.getUniformLocation(shaderProgram, 'right');
        glForward = gl.getUniformLocation(shaderProgram, 'forward');
        glUp = gl.getUniformLocation(shaderProgram, 'up');
        glOrigin = gl.getUniformLocation(shaderProgram, 'origin');
        glResolution = gl.getUniformLocation(shaderProgram, 'resolution');
        glLen = gl.getUniformLocation(shaderProgram, 'len');

        const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        gl.vertexAttribPointer(glPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(glPosition);
        
        setupUI();
        addEventListeners();
        
        window.onresize = onResize;
        onResize();
        
        requestAnimationFrame(draw);
    }

    function draw() {
        gl.useProgram(shaderProgram);

        const camOrigin = [
            len * Math.cos(ang1) * Math.cos(ang2) + cenx,
            len * Math.sin(ang2) + ceny,
            len * Math.sin(ang1) * Math.cos(ang2) + cenz
        ];
        const camRight = [Math.sin(ang1), 0, -Math.cos(ang1)];
        const camUp = [
            -Math.sin(ang2) * Math.cos(ang1),
            Math.cos(ang2),
            -Math.sin(ang2) * Math.sin(ang1)
        ];
        const camForward = [
            -Math.cos(ang1) * Math.cos(ang2),
            -Math.sin(ang2),
            -Math.sin(ang1) * Math.cos(ang2)
        ];

        gl.uniform2f(glResolution, canvas.width, canvas.height);
        gl.uniform1f(glLen, len);
        gl.uniform3fv(glOrigin, camOrigin);
        gl.uniform3fv(glRight, camRight);
        gl.uniform3fv(glUp, camUp);
        gl.uniform3fv(glForward, camForward);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(draw);
    }
    
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader derlenemedi:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linklenemedi:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    function onResize() {
        const size = Math.min(window.innerWidth, window.innerHeight);
        canvas.width = size;
        canvas.height = size;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }
    
    function setupUI() {
        document.getElementById("kernel").value = KERNEL;
        document.getElementById("btn-config").addEventListener("click", function() {
            const configDiv = document.getElementById("config-container");
            const isVisible = configDiv.style.display === "block";
            configDiv.style.display = isVisible ? "none" : "block";
            this.innerText = isVisible ? "CONFIG" : "HIDE";
        });
        document.getElementById("apply").addEventListener("click", function() {
            KERNEL = document.getElementById("kernel").value;
            const vertShader = createShader(gl, gl.VERTEX_SHADER, VSHADER_SOURCE);
            const fragShader = createShader(gl, gl.FRAGMENT_SHADER, FSHADER_SOURCE + KERNEL);
            const newProgram = createProgram(gl, vertShader, fragShader);
            if(newProgram) {
                shaderProgram = newProgram;
                 glPosition = gl.getAttribLocation(shaderProgram, 'position');
                glRight = gl.getUniformLocation(shaderProgram, 'right');
                glForward = gl.getUniformLocation(shaderProgram, 'forward');
                glUp = gl.getUniformLocation(shaderProgram, 'up');
                glOrigin = gl.getUniformLocation(shaderProgram, 'origin');
                glResolution = gl.getUniformLocation(shaderProgram, 'resolution');
                glLen = gl.getUniformLocation(shaderProgram, 'len');
                 const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.vertexAttribPointer(glPosition, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(glPosition);
            } else {
                alert("Shader derleme hatası! Detaylar için konsolu kontrol edin.");
            }
        });
        document.getElementById("cancel").addEventListener("click", function() {
            document.getElementById("kernel").value = KERNEL;
        });
    }
    
    function addEventListeners() {
        canvas.addEventListener("mousedown", (e) => {
            if (e.button === 0) isMouseDownLeft = true;
            if (e.button === 2) isMouseDownRight = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
            hasMouseMoved = false;
        });
        document.addEventListener("mouseup", (e) => {
            if (e.button === 0) isMouseDownLeft = false;
            if (e.button === 2) isMouseDownRight = false;
        });
        document.addEventListener("mousemove", (e) => {
            if (!isMouseDownLeft && !isMouseDownRight) return;
            hasMouseMoved = true;
            const dx = e.clientX - mouseX;
            const dy = e.clientY - mouseY;
            if (isMouseDownLeft) {
                ang1 += dx * 0.005;
                ang2 += dy * 0.005;
                ang2 = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, ang2));
            }
            if (isMouseDownRight) {
                const moveSpeed = len / canvas.height;
                cenx -= (dx * Math.sin(ang1) + dy * Math.cos(ang1) * Math.sin(ang2)) * moveSpeed;
                ceny += dy * Math.cos(ang2) * moveSpeed;
                cenz += (dx * Math.cos(ang1) - dy * Math.sin(ang1) * Math.sin(ang2)) * moveSpeed;
            }
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            len *= Math.exp(-e.deltaY * 0.001);
            len = Math.max(0.01, len);
        });
        canvas.addEventListener('contextmenu', e => {
            if(hasMouseMoved) e.preventDefault();
        });
    }

    window.onload = setup;
</script>
</body>
</html>
